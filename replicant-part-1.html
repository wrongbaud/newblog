<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Replicant: Reproducing a Fault Injection Attack on the Trezor One - VoidStar Security Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="https://wrongbaud.github.io/newblog/replicant-part-1.html">

        <meta name="author" content=""Matthew Alt"" />
        <meta name="keywords" content="fault-injection,chipwhisperer" />
        <meta name="description" content="This post aims to provide a road map and example of how to replicate a fault injection attack and the hurdles and shortcomings that can occur when attempting to do so. Furthermore, by outlining the process of replicating one of these attacks, we hope that readers come away from this post more confident in generating their own fault injection attacks or replicating pre-existing work." />

        <meta property="og:site_name" content="VoidStar Security Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Replicant: Reproducing a Fault Injection Attack on the Trezor One"/>
        <meta property="og:url" content="https://wrongbaud.github.io/newblog/replicant-part-1.html"/>
        <meta property="og:description" content="This post aims to provide a road map and example of how to replicate a fault injection attack and the hurdles and shortcomings that can occur when attempting to do so. Furthermore, by outlining the process of replicating one of these attacks, we hope that readers come away from this post more confident in generating their own fault injection attacks or replicating pre-existing work."/>
        <meta property="article:published_time" content="2022-08-19" />
            <meta property="article:section" content="Glitching" />
            <meta property="article:tag" content="fault-injection" />
            <meta property="article:tag" content="chipwhisperer" />
            <meta property="article:author" content=""Matthew Alt"" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://wrongbaud.github.io/newblog/theme/css/bootstrap.spacelab.min.css" type="text/css"/>
    <link href="https://wrongbaud.github.io/newblog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://wrongbaud.github.io/newblog/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="https://wrongbaud.github.io/newblog/theme/css/style.css" type="text/css"/>

        <link href="https://wrongbaud.github.io/newblog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="VoidStar Security Blog ATOM Feed"/>

        <link href="https://wrongbaud.github.io/newblog/feeds/glitching.atom.xml" type="application/atom+xml" rel="alternate"
              title="VoidStar Security Blog Glitching ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <a href="https://wrongbaud.github.io/newblog/" class="navbar-brand">
VoidStar Security Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://wrongbaud.github.io/newblog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-sm-9 col-sm-push-3">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="https://wrongbaud.github.io/newblog/replicant-part-1.html"
                       rel="bookmark"
                       title="Permalink to Replicant: Reproducing a Fault Injection Attack on the Trezor One">
                        Replicant: Reproducing a Fault Injection Attack on the Trezor One
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2022-08-19T00:00:00-06:00"> Fri 19 August 2022</time>
    </span>


            <span class="label label-default">By</span>
            <a href="https://wrongbaud.github.io/newblog/author/matthew-alt.html"><i class="fa fa-user"></i> "Matthew Alt"</a>

        <span class="label label-default">Category</span>
        <a href="https://wrongbaud.github.io/newblog/category/glitching.html">Glitching</a>


<span class="label label-default">Tags</span>
	<a href="https://wrongbaud.github.io/newblog/tag/fault-injection.html">fault-injection</a>
        /
	<a href="https://wrongbaud.github.io/newblog/tag/chipwhisperer.html">chipwhisperer</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <h1>Overview</h1>
<p>There has been a lot of public work in the last four or five years surrounding the security of cryptocurrency wallets. Much of this research has been in the realm of fault injection, which is the art/science of disrupting an embedded system just enough that it will cause undefined behavior to occur. The goal is to find a fault that allows one to modify the device's behavior to grant an attacker escalated levels of access. Examples of this might include skipping instructions, corrupting memory read operations, etc. </p>
<h1>Goals</h1>
<p>This post aims to provide a road map and example of how to replicate a fault injection attack and the hurdles and shortcomings that can occur when attempting to do so. Furthermore, by outlining the process of replicating one of these attacks, we hope that readers come away from this post more confident in generating their own fault injection attacks or replicating pre-existing work.</p>
<p>But before we dive into all that, let's briefly review what fault injection (FI) is and outline some resources you can use to get started in this space. </p>
<hr>
<h1>A Brief Primer on Fault Injection</h1>
<p>Fault injection involves introducing an error/modification minor enough to cause undefined behavior on a target but not enough to stop the target from operating entirely. This typically involves injecting a high voltage pulse or temporarily draining the voltage from a targeted power source or "rail" on the target system. </p>
<p>By causing momentary voltage modulations (either above or below the expected voltage), we can force our target system to enter a realm of <strong>undefined behavior</strong>. An adequately targeted fault can bypass various security checks or other features that may impede an attacker or reverse engineer. </p>
<p>With regards to the common fault injection methods, there are a few different <strong>types</strong> of faults that we can try to introduce: clock glitching and voltage glitching. </p>
<h2>Clock Glitching</h2>
<p>With clock glitching, our goal is to skip or modify instructions. The idea is that by injecting another clock cycle, we can cause the processor to skip over an instruction. </p>
<p><img alt="Clock Glitch" src="https://voidstarsec.com/blog/assets/images/glitch/clock.PNG"></p>
<p>As you can probably imagine, these need to be precise as we try to modify or manipulate a specific sequence of clock cycles to get our desired outcome. Clock glitching targets the external clock on a CPU or microcontroller with the end goal of injecting a clock signal at the appropriate time, causing an instruction to be skipped. </p>
<h2>Voltage Glitching</h2>
<p>Voltage glitching involves targeting the power source of the entire system. By briefly cutting the power to a target system, we can modify its behavior/performance. </p>
<p><img alt="Voltage Glitch Example" src="https://voidstarsec.com/blog/assets/images/glitch/voltage_glitch.drawio.png"></p>
<p>With voltage glitching, our goal is to reduce the voltage for a short enough time such that the processor does not entirely shut down but instead enters an undefined state or causes some type of <strong>undefined behavior</strong>. Unfortunately, this task does not come easy as many processors are specifically designed to avoid this scenario, sometimes requiring an attacker to get creative with component removal or injection methods. </p>
<p>If you want to learn more about these methods, I cannot recommend the NewAE materials highly enough. Even if you don't have a chipwhisperer at home, their <a href="https://github.com/newaetech/chipwhisperer-jupyter/tree/master/courses">tutorials</a>, <a href="https://forum.newae.com/">forums</a> and <a href="https://rtfm.newae.com/">documentation</a> are perfect for anyone wanting to learn more about fault injection. </p>
<h2>Electromagnetic Fault Injection</h2>
<p>We can also inject faults into our targets using something like the <a href="https://github.com/newaetech/chipshouter-picoemp">PicoEMP</a> or <a href="https://www.newae.com/products/NAE-CW520#:~:text=The%20ChipSHOUTER%C2%AE%20(CW520)%20is,%2C%20educators%2C%20and%20embedded%20enthusiasts.">chipshouter</a>, these tools inject faults in a different way than the two methods mentioned above.  </p>
<p><img alt="PicoEMP" src="https://github.com/newaetech/chipshouter-picoemp/blob/main/hardware/picoemp-red.jpeg?raw=true"></p>
<p>These tools are used to perform EMFI (electro-magnetic-fault-injection) attacks. These attacks involve generating a large electric field that can cause hardware to fail, resulting in potential bit-flips and other undefined behavior. For more information on EMFI attacks, check out <a href="https://www.youtube.com/watch?v=WOMAOGOvXnA">Colin O'Flynn's excellent talk on the same wallet we will review with this post</a>.</p>
<p>Now that we are a little more familiar with the ideas behind fault injection let's talk about the attack replicated in this post. This post aims to replicate the work presented in the <a href="https://chip.fail">chip.fail</a> presentation. This work outlines the process of using fault injection to bypass an RDP check in the bootrom of the STM32F2 series MCU, allowing the attacker to access the device's internal memory via SWD. This is the same attack that was <a href="https://www.forbes.com/sites/daveywinder/2022/02/07/hack-the-planet-how-this-hacker-unlocked-a-2-million-crypto-wallet/">recently replicated by Joe Grand</a> to recover a large amount of currency from the wallet. Before we get into the details of the attack, let's start by examining our target device and learning more about its security features.</p>
<hr>
<h1>Target Overview</h1>
<p>The target for this work is the <a href="https://shop.trezor.io/product/trezor-one-white">Trezor One</a> wallet. This is a popular low-cost wallet that is built around the STM32F2 microcontroller. Trezor's hardware and software are both open source, this is great because it gives us access to the hardware diagrams and the firmware source, which will help eliminate a lot of reverse engineering work.</p>
<p><img alt="Trezor One" src="https://voidstarsec.com/blog/assets/images/glitch/trez.jpg"></p>
<p>The Trezor One utilizes the STM32F2 MCU; before we move on, let's review some of the relevant CPU features.</p>
<h2>STM32 Security Overview</h2>
<p>Multiple security features can be enabled on an STM32 microprocessor; a brief description can be found below.</p>
<ul>
<li>
<p>RDP 0 - Flash unlocked, all-flash/ram is accessible via the debug interface</p>
</li>
<li>
<p>RDP 1 - Flash locked; you can connect a debugger and read out RAM/peripherals, but not flash. </p>
</li>
<li>
<p>RDP 2 - Flash locked, RAM reads locked, debug interface locked</p>
</li>
</ul>
<p>Our target has protection level RDP2 enabled, so we need to find a way around that; to do that, we have to take a slightly closer look at how power is managed and regulated within the STM32. </p>
<h2>STM32 Power Management/Regulation</h2>
<p>Within any microcontroller, there are multiple power domains; these are used for powering various chip peripherals and internal operations and comparators. We will be targeting the internal voltage regulator. A brief overview of the power domains in the STM32 can be seen below:</p>
<p><img alt="Power Domains on STM32" src="https://voidstarsec.com/blog/assets/images/glitch/power_domain_diagram.PNG"></p>
<p>This diagram shows that the <code>VCAP_1</code> and <code>VCAP_2</code> lines give us a direct path to the internal regulator, affecting things like kernel logic, flash memory, and IO logic. So if we can briefly manipulate this line, we can hopefully affect how these peripherals behave!</p>
<p><img alt="Power Domains 2" src="https://voidstarsec.com/blog/assets/images/glitch/power_domain.PNG"></p>
<p>For this work, we will be targetting the internal voltage regulator by attempting to manipulate the <code>VCAP</code> lines shown in the image above. Why are we targeting this line? Or more importantly, how can we find similar voltage rails to target other processors when we move on to additional targets for fault injection?</p>
<p>The <code>VCAP</code> lines ensure that all internal comparators and regulators are appropriately managed. If we can manipulate this line, we can potentially alter the behavior of the CPU's core memories and digital peripherals and cause undefined/modified behavior. Hopefully, glitching this internal regulator (perhaps during a specific memory operation involving the RDP settings) will allow us to modify the device's RDP state. </p>
<p>To recap, we want to attempt to modify the RDP state of the device from RDP2 to RDP1, and we want to do so by <strong>glitching</strong> or briefly interrupting the voltage supplied on the 
<code>VCAP_1</code>/<code>VCAP_2</code> lines are used to help regulate the internal voltage regulator. If we can modify the behavior of the internal voltage regulator, we can potentially alter the processor's behavior. Now that we have reviewed our target's internal security features and the power rail we will target, let's talk about the specifics of the attack. </p>
<hr>
<h1>The Attack</h1>
<p>This work aims to replicate the research presented in the <a href="chip.fail">chip.fail</a> research, which resulted in the discovery of a bug in the bootrom of the STM32F2 microcontroller. For those that may not be familiar, the bootrom is responsible for handling a lot of the early startup functionality of the microcontroller (similar to a BIOS on your modern computer). The bootrom is responsible for performing basic peripheral initialization, security checks, boot mode checks, and finally loading the main application into memory and executing it. A high-level outline of the boot process can be seen below:</p>
<p><img alt="Boot Sequence" src="https://voidstarsec.com/blog/assets/images/glitch/boot_sequence.drawio.png"></p>
<p>With the chip.fail research; It was discovered that if an attacker could inject a fault roughly 170 microseconds after the processor began executing its bootrom, an RDP check could be bypassed. This would allow an attacker to drop the STM32 from RDP2 to RDP1, allowing SRAM access via SWD. Additionally, the recovery keys could be extracted by reading SRAM, allowing access to the wallet's contents. (<strong>Note:</strong> Trezor has mitigated this bug by removing the recovery keys from RAM in updated firmware versions).</p>
<p>The attack:</p>
<ol>
<li>Power on the wallet</li>
<li>When the RESET line is asserted, begin the countdown to the glitch</li>
<li>At 170 microseconds, pull VCAP low</li>
<li>Test RDP bypass via SWD</li>
<li>Read SRAM from the target device</li>
</ol>
<p><img alt="DS1 For the Homies" src="https://voidstarsec.com/blog/assets/images/glitch/gwin.drawio.png"></p>
<p>If step 4 is successful and the wallet continues booting, the glitch is successful, and the internal SRAM can be read out of the target. </p>
<p>So what does an attack like this look like at the signal level? How do we know when the processor has started executing the boot ROM? How would one proceed if analyzing a new target/power trace? Let's start by removing a few components from our target and looking at a power trace. </p>
<hr>
<h1>Preparing our Target</h1>
<p>To make sure that our glitch is as effective as possible, we need to remove the external capacitors connected to the VCAP lines and the reset line. This can be done with a standard soldering iron and some patience. These capacitors (highlighted in the schematic below) are used to ensure that the voltage remains stable, which is what we <strong>don't</strong> want when doing fault injection.</p>
<p>Below is the default schematic for the Trezor One:</p>
<p><img alt="Stock Schematic" src="https://voidstarsec.com/blog/assets/images/glitch/trezor_v1.1.brd.png"></p>
<p>The highlighted components in red below outline capacitors that need to be removed.</p>
<p><img alt="Schematic with capacitors removed" src="https://voidstarsec.com/blog/assets/images/glitch/removal.jpg"></p>
<p>Below is an image of the wallet with the removed capacitors highlighted in red:</p>
<p><img alt="Trezor with Capacitors Removed" src="https://voidstarsec.com/blog/assets/images/glitch/trezor_caps_removed.jpg"></p>
<h2>Capturing Power Traces</h2>
<p>Now that we have identified the components that need to be removed and the lines we care about, we need to capture some example power trace data. To do this, we will use an oscilloscope. For our research, we used the Siglent SDS1104X-E 100Mhz Digital Oscilloscope and a standard DC measurement probe included with the scope.</p>
<p>When performing power captures like this, it is essential to make sure that you have your oscilloscope set up correctly. We configured our scope to trigger on the reset line using a rising edge trigger. This means the scope will begin capturing when it detects the reset line rising.</p>
<p>It is essential to take some time when dialing in your triggers for your oscilloscope. While it may be tempting to use something like continuous capture, or "Rolling" mode, this will drastically decrease your capture rate and result in less granular power traces. For the samples we will be reviewing later, our sample rate was 500MSa/s. </p>
<p>It should also be noted that we were not using a shunt resistor when we captured our traces; an article about how to properly utilize shunt resistors for power measurement can be found <a href="https://research.kudelskisecurity.com/2019/10/16/power-analysis-to-the-people/">here</a>. </p>
<p>Next, let's review some example power traces. Below is an example view of the voltage on the <code>VCAP</code> line <em>with</em> the external capacitors:</p>
<p><img alt="Capacitors on VCAP Line" src="https://voidstarsec.com/blog/assets/images/glitch/scope/cap.png"></p>
<p>Here is the same line with the capacitors removed:</p>
<p><img alt="No Capacitors on VCAP Line" src="https://voidstarsec.com/blog/assets/images/glitch/scope/nocap.png"></p>
<p>Notice that the line is now much noisier and less stable; this is what we want when attempting to inject a fault or a glitch onto a power rail. With our capacitors removed and our test pads soldered, let's perform some initial power analysis, starting with our target line (<code>VCAP</code>) as it relates to the <code>RESET</code> line. The bootrom begins execution when the system reset line hits the 3.3V threshold. Thus by monitoring the reset line, we can determine when the boot ROM begins execution; we will use this as our trigger for our glitch. </p>
<p>The pink line represents the voltage on the  <code>VCAP</code> line, while the yellow line is the voltage on the <code>RESET</code> line:</p>
<p><img alt="Simple Power Trace" src="https://voidstarsec.com/blog/assets/images/glitch/scope/power_trace.png"></p>
<p>We can see various activity regions highlighted in the gif below; notice the voltage fluctuations in these regions. Based on how this MCU boots, we can make some assumptions about what these multiple fluctuations mean. </p>
<p><img alt="Power Phases" src="https://voidstarsec.com/blog/assets/images/glitch/power/power.gif"></p>
<p>While our trace may look different than the one highlighted in the original research, we can see that our capture is similar in terms of the structure of the power trace. For example, if we look at our trace at roughly 170 microseconds, we can see the flash activity before the main application begins execution. </p>
<p><img alt="Timing Annotated" src="https://voidstarsec.com/blog/assets/images/glitch/scope/timing_power.png"></p>
<p>Now that we have removed the relevant capacitors, we next need to connect to the SWD port. This can be accessed through the vias on the right of the PCB, as shown in the image below:</p>
<p><img alt="Timing Annotated" src="https://voidstarsec.com/blog/assets/images/glitch/trezor-wiring.jpg"></p>
<p>With these lines broken out to a breadboard, it's time to replicate the attack.</p>
<hr>
<h1>Replicating the Attack</h1>
<p>For this work, we 3d printed a jig for the components, shown in the image below:</p>
<p><img alt="3D Printed Jig for Components" src="https://voidstarsec.com/blog/assets/images/glitch/setup.jpg"></p>
<p>The STL file can be found in the GitHub repo <a href="https://github.com/wrongbaud/replicant">here</a></p>
<h2>Hardware</h2>
<p>For our setup, we used a Raspberry Pi, <a href="https://rtfm.newae.com/Starter%20Kits/ChipWhisperer-Lite/">ChipWhisperer</a> and STLink. The STLink was connected to the SWD port of the Trezor and is what we use to detect that the RDP bypass has been performed successfully. The ChipWhisperer is used to power the wallet, trigger the reset line, and glitch the VCAP line. A simple wiring table for our setup can be seen below:</p>
<table>
<thead>
<tr>
<th>ChipWhisperer Pin Number / Usage</th>
<th>Trezor Pin</th>
</tr>
</thead>
<tbody>
<tr>
<td>(14) / <code>FPGA-TARG4</code></td>
<td><code>RST</code></td>
</tr>
<tr>
<td>(5) / <code>PROG-RESET</code></td>
<td><code>RST</code></td>
</tr>
<tr>
<td><code>Glitch Out</code></td>
<td><code>VCAP1</code></td>
</tr>
<tr>
<td>(3) / <code>+3.3V</code></td>
<td><code>VCC</code></td>
</tr>
<tr>
<td>(2) / <code>GND</code></td>
<td><code>GND</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>STLink Header</th>
<th>Trezor Pin</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GND</code></td>
<td><code>VDD</code></td>
</tr>
<tr>
<td><code>SWCLK</code></td>
<td><code>PA14</code></td>
</tr>
<tr>
<td><code>SWDIO</code></td>
<td><code>PA13</code></td>
</tr>
<tr>
<td><code>VTREF</code></td>
<td><code>VCC</code></td>
</tr>
</tbody>
</table>
<h2>Software</h2>
<p>With all the appropriate connections made, it is time to interface with the ChipWhisperer and dial in the parameters of our desired glitch. As mentioned before, the <a href="https://github.com/newaetech/chipwhisperer-jupyter/blob/master/courses/fault101/Fault%202_1%20-%20Introduction%20to%20Voltage%20Glitching.ipynb">NewAE tutorials</a> are a great place to start, and we used this notebook as a template for our attack. </p>
<p>A few key things need to be dialed in when working with the chip whisperer, and we'll walk through some of them now. The referenced code can be found <a href="https://github.com/wrongbaud/replicant/blob/main/replicant.py">here</a>.</p>
<p>The overall flow of the program is simple:</p>
<p><img alt="Glitch" src="https://voidstarsec.com/blog/assets/images/glitch/glitch_sequence.drawio.png"></p>
<p>Let's start with connecting to our CW; this can be done with the following code:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">chipwhisperer</span> <span class="k">as</span> <span class="nn">cw</span>
<span class="n">scope</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">scope</span><span class="p">()</span>
</code></pre></div>

<p>We need to make sure that we set the internal <a href="https://chipwhisperer.readthedocs.io/en/latest/scope-api.html#scope-clock">clock frequency</a> of the CW as well as the <a href="https://chipwhisperer.readthedocs.io/en/latest/scope-api.html#scope-glitch">output mode</a> and <a href="https://chipwhisperer.readthedocs.io/en/latest/scope-api.html#scope-trigger">trigger source</a>; we do this with the following lines:</p>
<div class="highlight"><pre><span></span><code><span class="n">scope</span><span class="o">.</span><span class="n">glitch</span><span class="o">.</span><span class="n">clk_src</span> <span class="o">=</span> <span class="s2">&quot;clkgen&quot;</span> <span class="c1"># set glitch input clock</span>
<span class="n">scope</span><span class="o">.</span><span class="n">glitch</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;enable_only&quot;</span> <span class="c1"># glitch_out = clk ^ glitch</span>
<span class="n">scope</span><span class="o">.</span><span class="n">glitch</span><span class="o">.</span><span class="n">trigger_src</span> <span class="o">=</span> <span class="s2">&quot;ext_single&quot;</span> <span class="c1"># glitch only after scope.arm() called</span>
</code></pre></div>

<p>Next, let's talk about triggering. We mentioned before that we would use the reset line to indicate when the boot ROM begins executing. This line will also be used to reset the target if the glitch is unsuccessful and needs to be rerun. </p>
<div class="highlight"><pre><span></span><code><span class="c1"># Trigger on IO4. This is connected to our reset line</span>
<span class="n">scope</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">triggers</span> <span class="o">=</span> <span class="s1">&#39;tio4&#39;</span>
</code></pre></div>

<p>The <code>reboot_flush</code> function is responsible for completely resetting the device and arming the glitch. We will call this function whenever we want to reset the STM32 and test new glitch parameters:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">reboot_flush</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">scope</span>
    <span class="c1"># Cut power to target device</span>
    <span class="n">scope</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">target_pwr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Pull reset low</span>
    <span class="n">scope</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">nrst</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Set up CW for glitching</span>
    <span class="n">scope</span><span class="o">.</span><span class="n">arm</span><span class="p">()</span>
    <span class="c1"># Put reset in high impedance mode (we are triggering off of it)</span>
    <span class="n">scope</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">nrst</span> <span class="o">=</span> <span class="s2">&quot;high_z&quot;</span>
    <span class="c1"># Power the target and wait for the glitch to trigger</span>
    <span class="n">scope</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">target_pwr</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div>

<p>Next, we will define our glitch parameters; we will do this using the GlitchController class as shown below:</p>
<div class="highlight"><pre><span></span><code><span class="n">gc</span> <span class="o">=</span> <span class="n">glitch</span><span class="o">.</span><span class="n">GlitchController</span><span class="p">(</span><span class="n">groups</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">,</span> <span class="s2">&quot;failure&quot;</span><span class="p">],</span> <span class="n">parameters</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="s2">&quot;ext_offset&quot;</span><span class="p">])</span>
<span class="n">gc</span><span class="o">.</span><span class="n">set_global_step</span><span class="p">(</span><span class="n">g_step</span><span class="p">)</span>
<span class="n">gc</span><span class="o">.</span><span class="n">set_range</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="n">gc</span><span class="o">.</span><span class="n">set_range</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">45</span><span class="p">,</span> <span class="o">-</span><span class="mi">45</span><span class="p">)</span>
<span class="n">gc</span><span class="o">.</span><span class="n">set_range</span><span class="p">(</span><span class="s2">&quot;ext_offset&quot;</span><span class="p">,</span> <span class="mi">15000</span><span class="p">,</span> <span class="mi">18000</span><span class="p">)</span>
<span class="n">scope</span><span class="o">.</span><span class="n">glitch</span><span class="o">.</span><span class="n">repeat</span><span class="o">=</span><span class="mi">20</span>
</code></pre></div>

<p>These last three lines are essential for our glitch's <strong>time</strong> and the <strong>shape</strong>. </p>
<h3>Shaping the Glitch</h3>
<p>The three variables we use to help shape our glitch are the <code>width</code>,<code>repeat</code>, and <code>offset</code> variables. Note that these definitions are pulled from the <a href="https://github.com/newaetech/chipwhisperer-jupyter/blob/master/courses/fault101/Fault%201_1%20-%20Introduction%20to%20Clock%20Glitching.ipynb">Newaetech Tutorials</a>. It should also be noted that many things can affect the shape of our glitch in addition to these variables such as wire length and quality. As a general rule of thumb using short shielded wires with SMA connectors is best practice. </p>
<ul>
<li><code>width</code>: How wide to make the glitch. This is the percentage of one period. For our example, we will use the maximum value as we are doing voltage glitching, not clock glitching. </li>
<li><code>repeat</code>: The number of clock cycles to repeat the glitch. Higher values increase the number of instructions that can be glitched but often increase the risk of crashing the target.  <strong>Note:</strong> a higher repeat typically results in a <strong>stronger</strong> glitch</li>
<li><code>offset</code>: Where in the output clock to place the glitch.</li>
</ul>
<p>These three variables can be manipulated to shape our glitch; we can change the width and overall strength of the glitch. Next, we have to determine <strong>when</strong> we trigger the glitch relative to some external signal on our target, which in our case will be the <code>RESET</code> line. </p>
<h3>Timing the Glitch</h3>
<p>The final range definition <code>ext_offset</code> defines how many clock cycles the FPGA will wait after triggering before performing the glitch. Since we previously specified a clock rate of 100 MHz, 15000 clock cycles equate to approximately 150 microseconds. This means that <strong>after</strong> the <code>RESET</code> line goes high on the Trezor, we will start counting down from our <code>ext_offset</code> value, and when it hits zero - we will glitch the <code>VCAP</code> line!</p>
<p>Another thing to note is that the GlitchController class will iterate over <strong>all</strong> of the glitch parameters provided. So for each possible combination of parameters we will be resetting the wallet, attempting the gitch and then attempting to connect to the STM32 via SWD. This means that for testing large ranges of values we may need <strong>multiple days</strong> to finish a series of tests. </p>
<p>We ran the first iteration of the glitch while monitoring with the scope and saw that our glitch was generated correctly. We let the glitch run over the weekend and were looking forward to returning to the office victorious with an active SWD port on our Trezor.</p>
<hr>
<h2>Debugging the Attack</h2>
<p>After running the attack for some time with no results, we began troubleshooting our setup. The first thing we wanted to debug was our STLink SWD enumeration code that was being used to detect a successful glitch:</p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">swd_check</span>
<span class="sd">Use the link to attempt to connect via SWD</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">swd_check</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">dev</span>
    <span class="kn">import</span> <span class="nn">swd</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">swd</span><span class="o">.</span><span class="n">Swd</span><span class="p">()</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span><span class="o">.</span><span class="n">str</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">swd</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">pc</span>
</code></pre></div>

<p>First, we tested the detection of a successful glitch by using an STM32 dev board at RDP level 0, which immediately worked on the first iteration. </p>
<p>This was a good sign, but we wanted to test what would happen when we called the <code>swd_check</code> function multiple times. </p>
<p>Upon doing so, we found out that after the swd library fails to enumerate a device (which would happen on a failed glitch attempt), it would not work again until the STLink had been re-enumerated via USB!</p>
<p>This meant that for <em>all</em> of our tests, only our first iteration was properly testing for SWD using the STLink. If it failed once, SWD would not work again until the probe had been unplugged and plugged back over USB!</p>
<p>Armed with this new knowledge and confident that we found our issue, we modified a <a href="https://github.com/wrongbaud/replicant/blob/main/usbreset.c">simple c program</a> to reset the STLink device after each glitch attempt.</p>
<div class="highlight"><pre><span></span><code><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">swd_check</span>
<span class="sd">Use the link to attempt to connect via SWD</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="nf">swd_check</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">dev</span>
    <span class="kn">import</span> <span class="nn">swd</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Reset the STLink</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sudo /home/pi/glitch/replicant/python/usbreset </span><span class="si">{</span><span class="n">usb_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">swd</span><span class="o">.</span><span class="n">Swd</span><span class="p">()</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span><span class="o">.</span><span class="n">str</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">swd</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">pc</span>
</code></pre></div>

<p>With this, we were <em>certain</em> that we'd found our issue. Everything else looked great and lined up with the public literature; what else could go wrong? But unfortunately, we were still not seeing results after a few more days of testing and tweaking glitch parameters. </p>
<p>Finally, we decided to get the scope back out and inspect our glitch. We examined the glitch with an <code>ext_offset</code> of 16000,17000, and 18000, and it <em>looked</em> reasonable to the naked eye. However, with an <code>ext_offset</code> of 0, we saw the following:</p>
<p><img alt="Bad Glitch" src="https://voidstarsec.com/blog/assets/images/glitch/scope/SDS00001.png"></p>
<p>In the screenshot above, the yellow line is our RST line, and purple is the VCAP line. Note the gap between the glitch and the reset line reaching its target voltage. The ChipWhisperer is triggering before the reset line reaches 3.3V. This early triggering was causing our glitch to start counting down before the reset line was fully asserted. This was causing the glitch to trigger about 20 microseconds too early.</p>
<p>We can calculate the exact delay using the cursors on the oscilloscope, as seen in the image below:</p>
<p><img alt="Voltage Differential" src="https://voidstarsec.com/blog/assets/images/glitch/scope/SDS00005.png"></p>
<p>We determined we were triggering approximately 24 microseconds too early using the oscilloscope. Armed with this new information, we modified our <code>ext_offset</code> range to be between 17000 and 20000 and left that running over the weekend.</p>
<p>When we returned to the office on Monday, the STLink LED was green, meaning it had successfully accessed the device via SWD! </p>
<div class="highlight"><pre><span></span><code>pi@voidstar:~/glitch/replicant<span class="w"> </span>$<span class="w"> </span>sudo<span class="w"> </span>-E<span class="w"> </span>python3<span class="w"> </span>python/replicant.py<span class="w"> </span>/dev/bus/usb/001/004
Found<span class="w"> </span>CW!
Success!<span class="w"> </span>--<span class="w"> </span><span class="nv">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>-44.921875,<span class="w"> </span><span class="nv">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">39</span>.84375,<span class="w"> </span><span class="nv">ext_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">19752</span>
<span class="nv">successes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="nv">failures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="nv">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>-44.921875,<span class="w"> </span><span class="nv">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">39</span>.84375,<span class="w"> </span><span class="nv">ext_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">19752</span>
Done<span class="w"> </span>glitching
</code></pre></div>

<p>Even more interesting is that our glitch hit around 197 microseconds after the ChipWhisperer triggered. Recall that in the chip.fail work; their offset was roughly 170 microseconds. Ours had a delay of 24 microseconds, placing it in a similar range to the previous research (197-24 = 173). This offset range was repeatable, and we could consistently trigger the glitch in the 194-197 microseconds range. </p>
<p><img alt="Video of Glitch Hitting" src="https://voidstarsec.com/blog/assets/images/glitch/glitch.gif"></p>
<p>We can now use OpenOCD to read the SRAM region with the glitch.</p>
<div class="highlight"><pre><span></span><code>pi@voidstar:~/glitch/replicant<span class="w"> </span>$<span class="w"> </span>./run_openocd.sh<span class="w"> </span>
Open<span class="w"> </span>On-Chip<span class="w"> </span>Debugger<span class="w"> </span><span class="m">0</span>.10.0+dev-01514-ga8edbd020-dirty<span class="w"> </span><span class="o">(</span><span class="m">2022</span>-03-01-19:24<span class="o">)</span>
Licensed<span class="w"> </span>under<span class="w"> </span>GNU<span class="w"> </span>GPL<span class="w"> </span>v2
For<span class="w"> </span>bug<span class="w"> </span>reports,<span class="w"> </span><span class="nb">read</span>
<span class="w">        </span>http://openocd.org/doc/doxygen/bugs.html
Info:<span class="w"> </span>auto-selecting<span class="w"> </span>first<span class="w"> </span>available<span class="w"> </span>session<span class="w"> </span>transport<span class="w"> </span><span class="s2">&quot;hla_swd&quot;</span>.<span class="w"> </span>To<span class="w"> </span>override<span class="w"> </span>use<span class="w"> </span><span class="s1">&#39;transport select &lt;transport&gt;&#39;</span>.
Info<span class="w"> </span>:<span class="w"> </span>The<span class="w"> </span>selected<span class="w"> </span>transport<span class="w"> </span>took<span class="w"> </span>over<span class="w"> </span>low-level<span class="w"> </span>target<span class="w"> </span>control.<span class="w"> </span>The<span class="w"> </span>results<span class="w"> </span>might<span class="w"> </span>differ<span class="w"> </span>compared<span class="w"> </span>to<span class="w"> </span>plain<span class="w"> </span>JTAG/SWD.
Info<span class="w"> </span>:<span class="w"> </span>Listening<span class="w"> </span>on<span class="w"> </span>port<span class="w"> </span><span class="m">6666</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>tcl<span class="w"> </span>connections
Info<span class="w"> </span>:<span class="w"> </span>Listening<span class="w"> </span>on<span class="w"> </span>port<span class="w"> </span><span class="m">11111</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>telnet<span class="w"> </span>connections
Info<span class="w"> </span>:<span class="w"> </span>clock<span class="w"> </span>speed<span class="w"> </span><span class="m">1000</span><span class="w"> </span>kHz
Info<span class="w"> </span>:<span class="w"> </span>STLINK<span class="w"> </span>V2J29S7<span class="w"> </span><span class="o">(</span>API<span class="w"> </span>v2<span class="o">)</span><span class="w"> </span>VID:PID<span class="w"> </span><span class="m">0483</span>:3748
Info<span class="w"> </span>:<span class="w"> </span>Target<span class="w"> </span>voltage:<span class="w"> </span><span class="m">3</span>.259749
Info<span class="w"> </span>:<span class="w"> </span>stm32f2x.cpu:<span class="w"> </span>hardware<span class="w"> </span>has<span class="w"> </span><span class="m">6</span><span class="w"> </span>breakpoints,<span class="w"> </span><span class="m">4</span><span class="w"> </span>watchpoints
Info<span class="w"> </span>:<span class="w"> </span>starting<span class="w"> </span>gdb<span class="w"> </span>server<span class="w"> </span><span class="k">for</span><span class="w"> </span>stm32f2x.cpu<span class="w"> </span>on<span class="w"> </span><span class="m">3333</span>
Info<span class="w"> </span>:<span class="w"> </span>Listening<span class="w"> </span>on<span class="w"> </span>port<span class="w"> </span><span class="m">3333</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>gdb<span class="w"> </span>connections
Info<span class="w"> </span>:<span class="w"> </span>accepting<span class="w"> </span><span class="s1">&#39;telnet&#39;</span><span class="w"> </span>connection<span class="w"> </span>on<span class="w"> </span>tcp/11111
</code></pre></div>

<p>With OpenOCD running, we can connect to it via telnet and read out SRAM:</p>
<div class="highlight"><pre><span></span><code>pi@voidstar:~/glitch/replicant<span class="w"> </span>$<span class="w"> </span>telnet<span class="w"> </span>localhost<span class="w"> </span><span class="m">11111</span>
Trying<span class="w"> </span>::1...
Trying<span class="w"> </span><span class="m">127</span>.0.0.1...
Connected<span class="w"> </span>to<span class="w"> </span>localhost.
Escape<span class="w"> </span>character<span class="w"> </span>is<span class="w"> </span><span class="s1">&#39;^]&#39;</span>.
Open<span class="w"> </span>On-Chip<span class="w"> </span>Debugger
&gt;<span class="w"> </span>dump_image<span class="w"> </span>sram2.bin<span class="w"> </span>0x20000000<span class="w"> </span>0x1FFFFFFF

&gt;<span class="w"> </span><span class="nb">exit</span>
Connection<span class="w"> </span>closed<span class="w"> </span>by<span class="w"> </span>foreign<span class="w"> </span>host.
pi@voidstar:~/glitch/replicant<span class="w"> </span>$<span class="w"> </span>hexdump<span class="w"> </span>-n512<span class="w"> </span>-C<span class="w"> </span>sram2.bin<span class="w"> </span>
<span class="m">00000000</span><span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="p">|</span>................<span class="p">|</span>
*
<span class="m">00000090</span><span class="w">  </span><span class="m">78</span><span class="w"> </span><span class="m">77</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">08</span><span class="w"> </span><span class="m">90</span><span class="w"> </span><span class="m">77</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">08</span><span class="w">  </span>ff<span class="w"> </span>ff<span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">13</span><span class="w"> </span><span class="m">70</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">08</span><span class="w">  </span><span class="p">|</span>xw...w.......p..<span class="p">|</span>
000000a0<span class="w">  </span>1f<span class="w"> </span><span class="m">70</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">08</span><span class="w"> </span><span class="m">26</span><span class="w"> </span><span class="m">70</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">08</span><span class="w">  </span><span class="m">24</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">28</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="p">|</span>.p..<span class="p">&amp;</span>p..$...<span class="o">(</span>...<span class="p">|</span>
000000b0<span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">01</span><span class="w"> </span><span class="m">04</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">01</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">01</span><span class="w"> </span><span class="m">57</span><span class="w"> </span><span class="m">49</span><span class="w">  </span><span class="p">|</span>..............WI<span class="p">|</span>
000000c0<span class="w">  </span>4e<span class="w"> </span><span class="m">55</span><span class="w"> </span><span class="m">53</span><span class="w"> </span><span class="m">42</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="p">|</span>NUSB............<span class="p">|</span>
000000d0<span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">80</span><span class="w"> </span>c3<span class="w"> </span>c9<span class="w"> </span><span class="m">01</span><span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">87</span><span class="w"> </span><span class="m">93</span><span class="w"> </span><span class="m">03</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="p">|</span>................<span class="p">|</span>
000000e0<span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w">  </span><span class="p">|</span>................<span class="p">|</span>
*
<span class="m">00000200</span>
</code></pre></div>

<p>A struct is present in the RAM dump that can be found at the <a href="https://github.com/trezor/trezor-firmware/blob/6fd4739c5c24ce93afdbe39af33f4a2bfae8ce45/core/embed/trezorhal/usb.c#L375">following lines of code</a>:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">wIndex</span><span class="w"> </span><span class="o">==</span>
<span class="n">USB_WINUSB_REQ_GET_COMPATIBLE_ID_FEATURE_DESCRIPTOR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">winusb_wcid</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// header</span>
<span class="w">        </span><span class="mh">0x28</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="c1">// dwLength</span>
<span class="w">        </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="c1">// bcdVersion</span>
<span class="w">        </span><span class="mh">0x04</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="c1">// wIndex</span>
<span class="w">        </span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="c1">// bNumSections</span>
<span class="w">        </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="c1">// reserved</span>
<span class="w">        </span><span class="c1">// functions</span>
<span class="w">        </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="c1">// bInterfaceNumber - HACK: we present only interface 0 as</span>
<span class="w">        </span><span class="c1">// WinUSB</span>
<span class="w">        </span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="c1">// reserved</span>
<span class="w">        </span><span class="sc">&#39;W&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;I&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;N&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;U&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;S&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;B&#39;</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="c1">// compatibleId</span>
<span class="w">        </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span>
<span class="w">        </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="c1">// subCompatibleId</span>
<span class="w">        </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="c1">// reserved</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">wait_random</span><span class="p">();</span>
<span class="w">    </span><span class="n">USBD_CtlSendData</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">UNCONST</span><span class="p">(</span><span class="n">winusb_wcid</span><span class="p">),</span>
<span class="w">    </span><span class="n">MIN_8bits</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">winusb_wcid</span><span class="p">)));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">USBD_OK</span><span class="p">;</span>

<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">wait_random</span><span class="p">();</span>
<span class="w">    </span><span class="n">USBD_CtlError</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">req</span><span class="p">);</span><span class="w">    </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">USBD_FAIL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><img alt="Structure Present in SRAM" src="https://voidstarsec.com/blog/assets/images/glitch/sram_highlight.png"></p>
<p>The image above shows the structure highlighted in an SRAM dump. We have successfully replicated the glitch and re-enabled the SWD peripheral. </p>
<hr>
<h1>Conclusion</h1>
<p>This work and post aimed to demonstrate the difficulties and technical hurdles that can occur when attempting to replicate a fault injection attack. We demonstrated the process of using fault injection to bypass an RDP check in the bootrom allowing for an attacker to gain privileged access. This post demonstrates that small details matter when replicating a FI attack, and these details can change based on your hardware setup. All of the code and resources that were generated for this work can be found <a href="https://github.com/wrongbaud/replicant">here</a> </p>
<p>You might be asking yourself, is there a way we could do this without connecting to the VCAP lines and removing those additional capacitors? Keep an eye out for part two of this post, where we build on the knowledge gained from this post and demonstrate this same attack but with a PicoEMP:</p>
<p><img alt="Pico EMP" src="https://voidstarsec.com/blog/assets/images/glitch/picoemp.jpg"></p>
<p>If you are interested in this type of hardware-level reverse engineering, check out <a href="https://voidstarsec.com/training">our training course</a> or <a href="https://voidstarsec.com/index.html#contact">reach out</a> to us for any consulting needs. If you want to get notified when a new blog post, course, or tool is released, consider signing up for the <a href="http://eepurl.com/hSl31f">mailing list</a>. I only send emails when there are actual posts or course updates. Lastly, you can follow me on <a href="https://twitter.com/wrongbaud">twitter</a> for various updates on side projects and classes. </p>
<p>This work was done alongside my friends Cody Gallagher and Aaron Phelps (<a href="https://www.linkedin.com/in/phelps-aaron/">LI</a>/<a href="https://twitter.com/phelps_yelps">twitter</a>), between the three of us we had a lot of fun replicating this attack. We also have to give a massive shout out to <a href="https://twitter.com/stacksmashing">@stacksmashing</a> and <a href="https://twitter.com/colinoflynn">@colinoflynn</a> who were very helpful and answered many of our early questions. </p>
<hr>
<h1>References / Resources</h1>
<h2>Talks / Resources / References</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=4u6BAH8mEDw">Thomas Roth (stacksmashing) FI Talk</a></li>
<li><a href="https://wallet.fail">wallet.fail</a></li>
<li><a href="https://chip.fail">chip.fail</a></li>
<li><a href="https://colinoflynn.com/2022/04/new-england-hardware-security-day-2022-talk/">Colin's Blog</a></li>
<li><a href="https://github.com/newaetech/chipwhisperer-jupyter/blob/master/courses/">Chipwhisperer Tutorials</a></li>
<li><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiy8sDUwcv5AhXakYkEHQkKC4EQFnoECAsQAQ&amp;url=https%3A%2F%2Fblog.kraken.com%2Fpost%2F3662%2Fkraken-identifies-critical-flaw-in-trezor-hardware-wallets%2F&amp;usg=AOvVaw3jkFjc1eeqT9tZeamjELJX">Kraken Blog</a></li>
<li><a href="http://grandideastudio.com/wp-content/uploads/adventures_of_wallet_hacking_slides.pdf">Joe Grand's Wallet Hacking</a></li>
<li><a href="https://www.st.com/resource/en/application_note/an3320-getting-started-with-stm32f20xxx21xxx-mcu-hardware-development-stmicroelectronics.pdf">STM32F2 Power Information</a></li>
<li><a href="https://www.st.com/resource/en/datasheet/stm32f207vg.pdf">STM32F2 Datasheet</a></li>
</ul>
<h2>Tools Used</h2>
<p>To replicate this attack, one will need the following:</p>
<ol>
<li><a href="https://www.newae.com/chipwhisperer">Chipwhisperer Lite</a></li>
<li>Python environment capable of installing the chipwhisperer package<ul>
<li><code>pip install chipwhisperer</code></li>
</ul>
</li>
<li><a href="https://shop.trezor.io/product/trezor-one-white">Trezor One</a></li>
<li><a href="https://www.adafruit.com/product/2548">STLink Programmer</a></li>
<li><a href="https://www.amazon.com/dp/B0771N1ZF9">Oscilloscope</a><ol>
<li>We used a Siglent Technologies SDS1104X-E</li>
</ol>
</li>
<li>Soldering equipment for component removal, etc</li>
</ol>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3 col-sm-pull-9" id="sidebar">
            <aside>
<!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Categories -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Categories</span></h4>
  <ul class="list-group" id="categories">
    <li class="list-group-item">
      <a href="https://wrongbaud.github.io/newblog/category/ghidra.html"><i class="fa fa-folder-open fa-lg"></i>Ghidra</a>
    </li>
    <li class="list-group-item">
      <a href="https://wrongbaud.github.io/newblog/category/glitching.html"><i class="fa fa-folder-open fa-lg"></i>Glitching</a>
    </li>
    <li class="list-group-item">
      <a href="https://wrongbaud.github.io/newblog/category/hardware.html"><i class="fa fa-folder-open fa-lg"></i>Hardware</a>
    </li>
    <li class="list-group-item">
      <a href="https://wrongbaud.github.io/newblog/category/training.html"><i class="fa fa-folder-open fa-lg"></i>Training</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Categories -->

<!-- Sidebar/Social -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
  <ul class="list-group" id="social">
    <li class="list-group-item"><a href="https://twitter.com/voidstarsec"><i class="fa fa-twitter-square fa-lg"></i> twitter</a></li>
    <li class="list-group-item"><a href="https://www.linkedin.com/in/voidstarsec"><i class="fa fa-linkedin-square fa-lg"></i> linkedin</a></li>
    <li class="list-group-item"><a href="https://github.com/voidstarsec"><i class="fa fa-github-square fa-lg"></i> github</a></li>
  </ul>
</li>
<!-- End Sidebar/Social -->

<!-- Sidebar/Links -->
<li class="list-group-item">
  <h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
  <ul class="list-group" id="links">
    <li class="list-group-item">
      <a href="https://voidstarsec.com/" target="_blank">VoidStar Security Website</a>
    </li>
    <li class="list-group-item">
      <a href="https://www.voidstarsec.training/" target="_blank">VoidStar Security Training</a>
    </li>
    <li class="list-group-item">
      <a href="https://www.voidstarsec.wiki/" target="_blank">Build a Hardware Hacking Lab</a>
    </li>
    <li class="list-group-item">
      <a href="https://hackaday.io/course/172292-introduction-to-reverse-engineering-with-ghidra" target="_blank">Free Ghidra Course</a>
    </li>
    <li class="list-group-item">
      <a href="https://www.wrongbaud.github.io/" target="_blank">Wrongbauds Blog (fun intro hacks)</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Links -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2024 VoidStar Security
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://wrongbaud.github.io/newblog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://wrongbaud.github.io/newblog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://wrongbaud.github.io/newblog/theme/js/respond.min.js"></script>




</body>
</html>